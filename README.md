# Tekana-eWallet Back-end Rebuild

## Project Overview

This project aims to rebuild the Tekana-eWallet legacy application's back-end system using Django and GraphQL. The Tekana-eWallet application is a globally used platform for money transfers, and this effort focuses on delivering a robust and innovative back-end solution.

## Table of Contents

- [Project Overview](#project-overview)
- [Requirements](#requirements)
- [Strategy](#strategy)
- [Technical Stack](#technical-stack)
- [Code Structure](#code-structure)
- [Database Design](#database-design)
- [API Design](#api-design)
- [Testing and Quality Assurance](#testing-and-quality-assurance)
- [Deployment](#deployment)
- [Documentation](#documentation)
- [Creativity and Innovation](#creativity-and-innovation)
- [Pilot System and Monitoring](#pilot-system-and-monitoring)

## Requirements

The following features need to be built in this back-end solution:

1. Create and Read customers (Registration)
2. Create and Read wallets of customers
3. Create and Read transactions

## Strategy

### Step 1: Project Kickoff

- **Gather Stakeholders:** Assemble the project team, including back-end developers, front-end developers, UI/UX designers, a product owner, Scrum Master, and subject matter experts.
- **Define Objectives:** Clearly define project objectives, constraints, timelines, and budget.
- **Tech Stack Selection:** Choose Django and GraphQL as the technology stack.

### Step 2: Requirements Gathering

- **Engage with Business Units:** Collaborate closely with the business team to understand customer needs and gather detailed requirements.
- **Document User Stories:** Create user stories and prioritize features for the pilot system.
- **Front-End Collaboration:** Work closely with the front-end team to ensure alignment between back-end and front-end requirements.

### Step 3: Architectural Design

- **High-Level Architecture:** Define the high-level architecture, considering scalability, security, and maintainability.
- **Data Model Design:** Design a robust data model for customers, wallets, and transactions.
- **API Design:** Plan the structure of GraphQL queries and mutations.

### Step 4: Development

- **Coding Standards:** Ensure that all developers follow coding standards and conventions.
- **Modular Code:** Create a modular codebase for enhanced maintainability and reusability.
- **Database Optimization:** Optimize the database for high performance, including indexing and normalization.
- **Documentation:** Include meaningful comments and documentation for easy testing and maintenance.
- **GraphQL Implementation:** Implement GraphQL queries, mutations, and schemas.

### Step 5: Testing and Quality Assurance

- **Unit Testing:** Execute unit tests to ensure code correctness.
- **Integration Testing:** Test the integration between different components.
- **Performance Testing:** Ensure the system can handle a large number of transactions.
- **Security Testing:** Validate the system's security measures, including data protection and authorization.

### Step 6: Documentation and Deployment

- **API Documentation:** Create clear and concise GraphQL API documentation.
- **Deployment:** Prepare the system for deployment, ensuring it can run without additional configuration.
- **Push to Git:** Push the source code to Git, making it accessible to recruiters.

### Step 7: Creativity and Innovation

- **Innovative Features:** Implement creative and innovative features to enhance the user experience.
- **Problem-Solving:** Identify and solve challenges uniquely.

### Step 8: Pilot System and Monitoring

- **Pilot Launch:** Deploy the pilot system in a controlled environment for testing and monitoring.
- **Monitoring:** Set up monitoring tools to track system performance and user behavior.
- **Feedback Loop:** Continuously collect feedback from users and stakeholders for further improvements.

## Technical Stack

- **Django:** The web framework for building the back-end.
- **GraphQL:** A query language for your API and a runtime for executing those queries by connecting to your data source.

## Code Structure

- The codebase is structured following Django best practices, ensuring modularity, readability, and maintainability.

## Database Design

- The database design focuses on high performance, using indexing and normalization where needed.

## API Design

- GraphQL is used to design the API, providing flexibility to clients to request the data they need.

## Testing and Quality Assurance

- Comprehensive testing has been conducted, including unit testing, integration testing, performance testing, and security testing.

## Deployment

- The application is designed to be deployed with minimal configuration.

## Documentation

- Detailed API documentation is available for ease of use by developers and stakeholders.

## Creativity and Innovation

- Innovative features have been implemented to enhance the user experience.

## Pilot System and Monitoring

- The pilot system has been deployed and is continuously monitored to ensure optimal performance.

## Git Repository

The source code for this project can be found on our [GitHub repository](insert_link_here).

## Questions and Support

If you have any questions or need support, please feel free to contact us at [juliushirwa@gmail.com].

